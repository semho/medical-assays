{% extends 'medical_analysis/base.html' %}

{% block title %}Динамика показателей - МедАнализатор{% endblock %}

{% block extra_css %}
<style>
    .chart-container {
        position: relative;
        height: 300px;  /* Уменьшили с 400px */
        margin-bottom: 20px;
    }
    .parameter-card {
        margin-bottom: 20px;
    }
    /* Сетка по 3 в строку */
    .charts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 20px;
    }

    @media (min-width: 1200px) {
        .charts-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    }

    @media (max-width: 768px) {
        .charts-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2"><i class="fas fa-chart-line me-2"></i>Динамика показателей</h1>
</div>

<div class="row mb-4">
    <div class="col-md-6">
        <label for="analysisTypeSelect" class="form-label">Выберите тип анализа:</label>
        <select id="analysisTypeSelect" class="form-select">
            <option value="">-- Выберите тип --</option>
            {% for type_value, type_name in analysis_types %}
                {% if type_value in available_types %}
                    <option value="{{ type_value }}">{{ type_name }}</option>
                {% endif %}
            {% endfor %}
        </select>
    </div>
</div>

<div id="chartsContainer">
    <div class="alert alert-info">
        <i class="fas fa-info-circle me-2"></i>
        Выберите тип анализа для отображения графиков динамики
    </div>
</div>

<div id="loadingSpinner" class="text-center d-none">
    <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Загрузка...</span>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script>
let charts = [];

document.getElementById('analysisTypeSelect').addEventListener('change', function() {
    const analysisType = this.value;
    if (!analysisType) {
        document.getElementById('chartsContainer').innerHTML = `
            <div class="alert alert-info">
                <i class="fas fa-info-circle me-2"></i>
                Выберите тип анализа для отображения графиков динамики
            </div>
        `;
        return;
    }
    
    loadTrendsData(analysisType);
});

function loadTrendsData(analysisType) {
    // Показываем спиннер
    document.getElementById('loadingSpinner').classList.remove('d-none');
    document.getElementById('chartsContainer').innerHTML = '';
    
    // Уничтожаем старые графики
    charts.forEach(chart => chart.destroy());
    charts = [];
    
    fetch(`/trends/data/${analysisType}/`)
        .then(response => response.json())
        .then(data => {
            document.getElementById('loadingSpinner').classList.add('d-none');
            
            if (data.error) {
                document.getElementById('chartsContainer').innerHTML = `
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        ${data.error}
                    </div>
                `;
                return;
            }
            
            if (Object.keys(data).length === 0) {
                document.getElementById('chartsContainer').innerHTML = `
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Нет данных для построения графиков
                    </div>
                `;
                return;
            }
            
            renderCharts(data);
        })
        .catch(error => {
            document.getElementById('loadingSpinner').classList.add('d-none');
            console.error('Ошибка загрузки данных:', error);
            document.getElementById('chartsContainer').innerHTML = `
                <div class="alert alert-danger">
                    <i class="fas fa-times-circle me-2"></i>
                    Ошибка загрузки данных: ${error.message}
                </div>
            `;
        });
}

function renderCharts(parametersData) {
    const container = document.getElementById('chartsContainer');

    // Создаём grid-контейнер
    const gridContainer = document.createElement('div');
    gridContainer.className = 'charts-grid';
    container.appendChild(gridContainer);

    Object.entries(parametersData).forEach(([paramKey, paramData]) => {
        // Создаём карточку для каждого параметра
        const card = document.createElement('div');
        card.className = 'card parameter-card';
        card.innerHTML = `
            <div class="card-header bg-light">
                <h6 class="mb-0">${paramData.name}</h6>
                <small class="text-muted">${paramData.units || ''}</small>
            </div>
            <div class="card-body p-2">
                <div class="chart-container">
                    <canvas id="chart-${paramKey}"></canvas>
                </div>
            </div>
        `;
        gridContainer.appendChild(card);  // Добавляем в grid вместо container

        // Создаём график
        const ctx = document.getElementById(`chart-${paramKey}`).getContext('2d');

        // Проверяем выход за референсные значения
        const hasReference = paramData.reference_min.some(v => v !== null);

        const datasets = [{
            label: paramData.name,
            data: paramData.values,
            borderColor: getLineColor(paramData.values, paramData.reference_min, paramData.reference_max),
            backgroundColor: 'rgba(13, 110, 253, 0.1)',
            tension: 0.4,
            fill: true,
            pointRadius: 4,  // Уменьшили точки
            pointHoverRadius: 6,
            segment: {
                borderColor: ctx => getSegmentColor(ctx, paramData.reference_min, paramData.reference_max)
            }
        }];

        // Добавляем референсные границы
        if (hasReference) {
            const refMin = paramData.reference_min[0];
            const refMax = paramData.reference_max[0];

            if (refMin !== null) {
                datasets.push({
                    label: 'Мин',
                    data: Array(paramData.dates.length).fill(refMin),
                    borderColor: 'rgba(220, 53, 69, 0.5)',
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false
                });
            }

            if (refMax !== null) {
                datasets.push({
                    label: 'Макс',
                    data: Array(paramData.dates.length).fill(refMax),
                    borderColor: 'rgba(220, 53, 69, 0.5)',
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false
                });
            }
        }

        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: paramData.dates.map(d => new Date(d).toLocaleDateString('ru-RU', {
                    day: '2-digit',
                    month: '2-digit'
                })),
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            boxWidth: 20,
                            font: {
                                size: 11
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += context.parsed.y.toFixed(2);
                                if (paramData.units) {
                                    label += ' ' + paramData.units;
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        ticks: {
                            font: {
                                size: 10
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: 10
                            }
                        }
                    }
                }
            }
        });

        charts.push(chart);
    });
}

function getLineColor(values, refMin, refMax) {
    // Проверяем, выходят ли значения за референсы
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        const min = refMin[i];
        const max = refMax[i];
        
        if ((min !== null && value < min) || (max !== null && value > max)) {
            return 'rgba(220, 53, 69, 1)'; // Красный если есть отклонения
        }
    }
    return 'rgba(13, 110, 253, 1)'; // Синий если все в норме
}

function getSegmentColor(ctx, refMin, refMax) {
    const value = ctx.p1.parsed.y;
    const index = ctx.p1.$context.dataIndex;
    const min = refMin[index];
    const max = refMax[index];
    
    if ((min !== null && value < min) || (max !== null && value > max)) {
        return 'rgba(220, 53, 69, 1)'; // Красный
    }
    return 'rgba(13, 110, 253, 1)'; // Синий
}
</script>
{% endblock %}